use std::collections::HashSet;

use actix_web::web::Data;
use actix_web::{App, HttpServer};
use anyhow::{anyhow, Context, Result};
use clap::Parser;
use ethers::types::{Address, H160};
use ethers::utils::public_key_to_address;
use k256::ecdsa::SigningKey;
use tokio::fs;

use serverless::cgroups::Cgroups;
use serverless::node_handler::{
    export_signed_registration_message, get_executor_details, index, inject_immutable_config,
    inject_mutable_config,
};
use serverless::utils::AppState;

// EXECUTOR CONFIGURATION PARAMETERS
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    // Server port
    #[clap(long, value_parser, default_value = "6001")]
    port: u16,

    // Runtime path where code and config files will be created and executed (workerd binary should be present)
    #[clap(long, value_parser, default_value = "./runtime/")]
    workerd_runtime_path: String,

    // Common chain id
    #[clap(long, value_parser, default_value = "421614")]
    common_chain_id: u64,

    // Http url of the RPC endpoint
    #[clap(
        long,
        value_parser,
        default_value = "https://sepolia-rollup.arbitrum.io/rpc"
    )]
    http_rpc_url: String,

    // Websocket url of the RPC endpoint
    #[clap(
        long,
        value_parser,
        default_value = "wss://arb-sepolia.g.alchemy.com/v2/U8uYtmU3xK9j7HEZ74riWfj3C4ode7n1"
    )]
    web_socket_url: String,

    // Executors smart contract address on common chain
    #[clap(
        long,
        value_parser,
        default_value = "0xE35E287DBC371561E198bFaCBdbEc9cF78bDe930"
    )]
    executors_contract_addr: String,

    // Jobs smart contract address on common chain
    #[clap(
        long,
        value_parser,
        default_value = "0xd3b682f6F58323EC77dEaE730733C6A83a1561Fd"
    )]
    jobs_contract_addr: String,

    // User code calldata smart contract address on common chain
    #[clap(
        long,
        value_parser,
        default_value = "0x44fe06d2940b8782a0a9a9ffd09c65852c0156b1"
    )]
    code_contract_addr: String,

    // path to enclave secp256k1 private key file
    #[clap(long, value_parser, default_value = "./id.sec")]
    enclave_signer_file: String,

    // Execution buffer time as configured on common chain (in seconds)
    #[clap(long, value_parser, default_value = "20")]
    execution_buffer_time: u64,

    // Number of executors selected at a time to execute a job as configured on common chain
    #[clap(long, value_parser, default_value = "3")]
    num_selected_executors: u8,
}

#[tokio::main]
// Program to run the executor
async fn main() -> Result<()> {
    let cli = Args::parse();

    // Initialize the 'cgroups' available inside the enclave to execute user code
    let cgroups = Cgroups::new().context("Failed to retrieve cgroups")?;
    if cgroups.free.is_empty() {
        return Err(anyhow!("No cgroups found, make sure you have generated cgroups on your system using the instructions in the readme"));
    }

    // Read the 'secp256k1' private and public key of the enclave instance generated by keygen
    let enclave_signer_key = SigningKey::from_slice(
        fs::read(cli.enclave_signer_file)
            .await
            .context("Failed to read the enclave signer key")?
            .as_slice(),
    )
    .context("Invalid enclave signer key")?;

    let enclave_address = public_key_to_address(&enclave_signer_key.verifying_key());

    // Initialize App data that will be shared across multiple threads and tasks
    let app_data = Data::new(AppState {
        job_capacity: cgroups.free.len(),
        cgroups: cgroups.into(),
        workerd_runtime_path: cli.workerd_runtime_path,
        execution_buffer_time: cli.execution_buffer_time,
        common_chain_id: cli.common_chain_id,
        http_rpc_url: cli.http_rpc_url,
        ws_rpc_url: cli.web_socket_url,
        executors_contract_addr: cli
            .executors_contract_addr
            .parse::<Address>()
            .context("Invalid Executors contract address")?,
        jobs_contract_addr: cli
            .jobs_contract_addr
            .parse::<Address>()
            .context("Invalid Jobs contract address")?,
        code_contract_addr: cli.code_contract_addr,
        num_selected_executors: cli.num_selected_executors,
        enclave_address: enclave_address,
        enclave_signer: enclave_signer_key,
        immutable_params_injected: false.into(),
        mutable_params_injected: false.into(),
        enclave_registered: false.into(),
        events_listener_active: false.into(),
        enclave_owner: H160::zero().into(),
        http_rpc_client: None.into(),
        job_requests_running: HashSet::new().into(),
        last_block_seen: 0.into(),
    });

    // Start actix server to expose the executor outside the enclave
    let server = HttpServer::new(move || {
        App::new()
            .app_data(app_data.clone())
            .service(index)
            .service(inject_immutable_config)
            .service(inject_mutable_config)
            .service(get_executor_details)
            .service(export_signed_registration_message)
    })
    .bind(("0.0.0.0", cli.port))
    .context(format!("could not bind to port {}", cli.port))?
    .run();

    println!("Node server started on port {}", cli.port);

    server.await?;

    Ok(())
}
