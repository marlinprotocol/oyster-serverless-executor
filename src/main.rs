use std::collections::HashSet;

use actix_web::web::Data;
use actix_web::{App, HttpServer};
use anyhow::{anyhow, Context, Result};
use clap::Parser;
use ethers::types::{H160, U256};
use ethers::utils::public_key_to_address;
use k256::ecdsa::SigningKey;
use tokio::fs;

use serverless::cgroups::Cgroups;
use serverless::node_handler::*;
use serverless::utils::{load_abi_from_file, AppState, ConfigManager};

// EXECUTOR CONFIGURATION PARAMETERS
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Cli {
    // Server port
    #[clap(long, value_parser, default_value = "6001")]
    port: u16,

    // Path to the configuration file
    #[clap(
        long,
        value_parser,
        default_value = "./oyster_serverless_executor_config.json"
    )]
    config_file: String,
}

#[tokio::main]
// Program to run the executor
async fn main() -> Result<()> {
    let args = Cli::parse();
    let config_manager = ConfigManager::new(&args.config_file);
    let config = config_manager.load_config().unwrap();

    // Initialize the 'cgroups' available inside the enclave to execute user code
    let cgroups = Cgroups::new().context("Failed to retrieve cgroups")?;
    if cgroups.free.is_empty() {
        return Err(anyhow!("No cgroups found, make sure you have generated cgroups on your system using the instructions in the readme"));
    }

    // Read the 'secp256k1' private and public key of the enclave instance generated by keygen
    let enclave_signer_key = SigningKey::from_slice(
        fs::read(config.enclave_signer_file)
            .await
            .context("Failed to read the enclave signer key")?
            .as_slice(),
    )
    .context("Invalid enclave signer key")?;

    let enclave_address = public_key_to_address(&enclave_signer_key.verifying_key());

    // Initialize App data that will be shared across multiple threads and tasks
    let app_data = Data::new(AppState {
        job_capacity: cgroups.free.len(),
        cgroups: cgroups.into(),
        workerd_runtime_path: config.workerd_runtime_path,
        execution_buffer_time: config.execution_buffer_time,
        common_chain_id: config.common_chain_id,
        http_rpc_url: config.http_rpc_url,
        ws_rpc_url: config.web_socket_url,
        executors_contract_addr: config.executors_contract_addr,
        jobs_contract_addr: config.jobs_contract_addr,
        code_contract_addr: config.code_contract_addr,
        num_selected_executors: config.num_selected_executors,
        enclave_address: enclave_address,
        enclave_signer: enclave_signer_key,
        immutable_params_injected: false.into(),
        mutable_params_injected: false.into(),
        enclave_registered: false.into(),
        events_listener_active: false.into(),
        enclave_owner: H160::zero().into(),
        http_rpc_client: None.into(),
        job_requests_running: HashSet::new().into(),
        last_block_seen: 0.into(),
        nonce_to_send: U256::from(0).into(),
        jobs_contract_abi: load_abi_from_file()?,
    });

    // Start actix server to expose the executor outside the enclave
    let server = HttpServer::new(move || {
        App::new()
            .app_data(app_data.clone())
            .service(index)
            .service(inject_immutable_config)
            .service(inject_mutable_config)
            .service(get_executor_details)
            .service(export_signed_registration_message)
    })
    .bind(("0.0.0.0", args.port))
    .context(format!("could not bind to port {}", args.port))?
    .run();

    println!("Node server started on port {}", args.port);

    server.await?;

    Ok(())
}
